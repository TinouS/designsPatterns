# Design Patterns
Design patterns implemented in Java ! (simple & small examples)

## Creational Patterns:

&#x1F53A;<strong>Singleton</strong> : Ensure a class only has one access, and provide a global point of access to it.

&#x1F53A;<strong>Abstract Factory</strong> : Provide an interface for creating families of related or independent objects without specifying their concrete classes.

&#x1F53A;<strong>Prototype</strong> : Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.

&#x1F53A;<strong>Factory Method</strong> : Define an interface for creating an object, but let the subclasses decide which class to instantiate. The Factory method lets a class defer instantiation to subclasses.

&#x1F53A;<strong>Builder</strong> : Separate the construction of a complex object from its representation so that the same construction process can create different representations.

## Structural Patterns:

&#x1F53A;<strong>Bridge</strong> : Decouple an abstraction from its implementation so that the two can vary independently. 

&#x1F53A;<strong>Proxy</strong> : Provide a surrogation or placeholder for another object to control access to it.

&#x1F53A;<strong>Composite</strong> : Compose objects into tree structures to represent part-whole hierarchies.Composite lets clients treat undividual objects and composition of objects uniformly.  

&#x1F53A;<strong>Decorator</strong> : Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.  

&#x1F53A;<strong>Adapter</strong> : Convert the interface of a class into another interface clients expects. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.

&#x1F53A;<strong>Facade</strong> : Provide a unified interface to a set of interfaces in a subsystem. Facade define a higher-level interface that makes the subsystem easier to use. 

&#x1F53A;<strong>Flyweight</strong> : Use sharing to support large numbers of fine-grained objects efficiently.

## Behavioral Patterns:

&#x1F53A;<strong>Observer</strong> : Define a one to many dependency between objects so that when one objects change state, all its dependents are notified and updated automatically.

&#x1F53A;<strong>Visitor</strong> : Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which its operates.

&#x1F53A;<strong>Memento</strong> : Without violating encapsulation, capture and externalize an object's internal state so that the object can be restored to this state later.

&#x1F53A;<strong>Iterator</strong> : Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation. 	  

&#x1F53A;<strong>Chain of Responsibility</strong> : Avoid coupling the sender of request to its receiver by given more than one object a chance to handle the request. chain the receiving objects and pass the request along the chain until an object handle it.  

&#x1F53B;<strong>Mediator</strong> : 

&#x1F53A;<strong>Command</strong> : Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations. 

## source:
Design Patterns - Elements of reusable object-oriented Software. (Gang of Four) &#x1F4D8;
		
							Erich Gamma
							Richard Helm
							Ralph Johson
							John Vlissides
